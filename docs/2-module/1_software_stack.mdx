---
sidebar_position: 1
---

# Programming an Underwater Robot: Software Stack

## ROS2 Terminology

ROS2 (Robot Operating System 2) is a set of open-source libraries and tools used to build robotics applications. It is commonly used in robotics research and industry.

### Nodes

Nodes are instances of executables that act as individual computation entitites in the ROS2 environment. They perform specific tasks, such as processing sensor data or controlling hardware. Nodes communicate with each other by publishing and subscribing to topics or by using services. Nodes typically consist of combinations of publishers, subscribers, and services.

### Topics

Topics are named buses that nodes use to exchange messages. Nodes can both publish messages on a topic and receive messages in a callback function on a subscribed topic. Each topic is limited to an individual message type specified in a node's executable.

### Messages

Messages are data structures used to communicate information betyouen nodes via topics. These structures contain combinations of fields and data types, and are defined in .msg files. The field is the name of specific data in the structure, while the data type is typically either a primitive data type or another message type. Messages define specific information such as sensor data or control input.

For example, in the built-in geometry_msgs package, a `Vector3` message defines a vector in free space. `Vector3.msg` is structured as:

```bash
float64 x
float64 y
float64 z
```

In this message type, there are three fields representing the magnitude of the vector in the primary axes. Each of these fields represents a float64 value in the message.

### Publishers & Subscribers

Publishers and subscribers are communication interfaces that enable nodes to communicate. A publisher sends messages on a topic and a subscriber receives messages on a topic.

### Services

Services and clients provide an alternate communication interface with a request-response mechanism. A client sends requests to a service and receives responses after the service completes its task.

## ROS2 Environment

To access ROS2 packages from a terminal, the ROS2 environments must be sourced. There are two types of environments: the ROS2 distribution from the installation process and ROS2 workspaces. First, setup the `.zshrc` file to automatically source the ROS2 installation. In a terminal, type:

```bash
echo "source /opt/ros/jazzy/setup.zsh" >> $HOME/.zshrc
```

Then, create a workspace for this course named `auvc_ws`:

```bash
cd && mkdir auvc_ws && cd auvc_ws && mkdir src
```

In a workspace, all user-defined packages are located within the `src` directory. The ROS2 compiler `colcon` will not compile your packages if they are not located in the `src` directory of the workspace you are currently building. Initialize the workspace by building with an empty `src` directory. 

```bash
cd ~/auvc_ws && colcon build
```

Now, setup the `.zshrc` file to automatically source the `auvc_ws` ROS2 workspace. In a terminal, type:

```bash
echo "source $HOME/auvc_ws/install/setup.zsh" >> $HOME/.zshrc
```

Then, resource the `.zshrc` file:

```bash
source ~/.zshrc
```

Now, all distribution packages and all your user-defined packages in `~/auvc_ws/src` will be automatically sourced in every new terminal that you open. Without this step, you would need to execute both lines added to the `.zshrc` file in every new terminal opened; otherwise, ROS2 would be inaccessible in that terminal.

## ROS2 Terminal Commands

Here are some terminal commands that you may find useful for general use and testing/debugging.

### General Use

1. Build packages in a ROS2 workspace:
- Packages must be located in your_ws/src/.
- Build command must be run in your_ws/.

```bash
colcon build
```

2. Build packages in a ROS2 workspace with symbolic links (recommended):

```bash
colcon build --symlink-install
```

3. Build specific packages in ROS2 workspace:

```bash
colcon build --packages-select my_package
```

4. Run an individual node:
- If the executable is not found, try `source ~/.zshrc` and then `chmod +x $HOME/auvc_ws/src/path_to_executable`.

```
ros2 run my_package my_executable.py
```

5. Create a new node:
- You will need to configure the `CMakeLists.txt` and `package.xml` files like as shown in ROS2 Example Nodes.

```bash
ros2 pkg create --build-type ament_cmake your_node_name
```

### Testing & Debugging

1. View a list of all active nodes:

```bash
ros2 node list
```

2. View a list of all named topics:

```bash
ros2 topic list
```

3. View the message type of a topic:

```bash
ros2 topic type /your/topic
```

4. View messages on a topic in the terminal:

```bash
ros2 topic echo /your/topic
```

5. Publish a message on a topic (replace `N` with the number of times you want to publish the message):

```bash
ros2 topic pub -N /your/topic std_msgs/String "{data: 'hello from terminal'}"
```

6. View a topic's rate:

```bash
ros2 topic hz /your/topic
```

## ROS2

This section provides an overview of an offical [ROS2 tutorial](https://docs.ros.org/en/jazzy/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html) for writing a simple publisher and subscriber with some modifications.

```bash
cd ~/auvc_ws/src && git clone https://github.com/blksail-edu/ros_bluerov2
cd ../ && colcon build --symlink-install
```

### Publisher Node

To start, navigate to into_to_ros package using `cd ~/auvc_ws/src/ros_bluerov2/intro_to_ros` and then open `publisher.py` with your favorite text editor. The first few lines of code import `rclpy`, the ROS2 client library for Python. You must also import any message types that the node uses. Add the following lines:

```bash
#!/env/usr/bin python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Vector3
```

Next, create a class which inherits from `Node`:

```bash
class TutorialPublisher(Node):
```

Now add the class's constructor. `super().__init__("nodename")` initializes a node called nodename. `create_publisher` declares that the node publishes the named message type to the named topic and its queue size.

```bash
def __init__(self):
    super().__init__("tutorial_publisher")
    self.pub = self.create_publisher(Vector3, "/tutorial/vector3", 10)
    self.get_logger().info("Started Tutorial Publisher Node")
```

In this case, the publisher named `pub` will publish `Vector3` messages to the topic named `/tutorial/vector3`. Define a method to run the node. For this node, you want to publish a single `Vector3` message and then shutdown the node. Add the following method to the `TutorialPublisher` class:

```bash
def run_node(self):
    msg = Vector3()
    msg.x = 3
    msg.y = 4
    msg.z = 5
    self.pub.publish(msg)
    self.get_logger().info("Vector3 msg published to /tutorial/vector3")
```

Lastly, you define the main function:

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialPublisher()
    node.run_node()
    node.destroy_node()
    rclpy.shutdown()

if __name__=="__main__":
    main()
```

### Subscriber Node

Save and exit the `publisher.py` file. Now open `subscriber.py`. In this node, you want to subscribe to messages published by `publisher.py` and print the corresponding unit vector to the terminal. you start with the same imports used in the publisher node. Then, define your class and constructor:

```bash
class TutorialSubscriber(Node)
```

```bash
def __init__(self):
    self.sub = self.create_subscription(
        Vector3,
        "/tutorial/vector3",
        self.callback,
        10
    )
    self.subscription
    self.get_logger().info("Started Tutorial Subscriber Node")
```

In the class's constructor, `create_subscription` declares that the node subscribes to `Vector3` messages on the named topic `/tutorial/vector3` and that these messages are directed to the `callback` method. Next, define the callback method:

```bash
def callback(self, msg):
    magnitude = np.sqrt(msg.x ** 2 + msg.y ** 2 + msg.z ** 2)
    data = Vector3()
    data.x = msg.x / magnitude
    data.y = msg.y / magnitude
    data.z = msg.z / magnitude
    self.get_logger().info(f"\nVector3\n\tx: {data.x}\n\ty: {data.y}\n\tz: {data.z})
```

Lastly, you define our main function:

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__=="__main__":
    main()
```

Here, instead of having the node perform a single task like the publisher node, you use `rclpy.spin` to keep the node active.

### Building the Nodes

To build the nodes, you must update `CMakeLists.txt` and `package.xml` with the dependencies from our nodes. First, open `CMakeLists.txt` and add `find_package` for each package defined in any nodes in the packages `src` directory.

```bash
find_package(rclpy REQUIRED)
find_package(geometry_msgs REQUIRED)

ament_python_install_package(src)
```

You must also specify executables in the node. Below `ament_python_install_package` add:

```bash
install(PROGRAMS
    src/publisher.py
    src/subscriber.py
    DESTINATION lib/${PROJECT_NAME}
)
```

Second, open `package.xml` and add a `build_depend` and `exec_depend` line for each imported module. Below `buildtool_depend` add:

```bash
<build_depend>rclpy</build_depend>
<build_depend>geometry_msgs</build_depend>

<exec_depend>rclpy</exec_depend>
<exec_depend>geometry_msgs</exec_depend>
```

Now navigate to the ROS2 workspace  and build the nodes.

```bash
cd ~/auvc_wc
colcon build --symlink-install
```

### Testing the Nodes

Open a new terminal and start the subscriber node:

```bash
ros2 run intro_to_ros subscriber.py
```

In the terminal, you should see the message the subscriber node has started. Open a second terminal and run the publisher node:

```bash
ros2 run intro_to_ros publisher.py
```

In the terminal running the subscriber node, you should see the unit vector equivalent of the `Vector3` message received from the publisher node.






## Problem Set

### Problem One

Create a new ROS2 node in the `intro_to_ros` package. Your node should subscribe to `geometry_msgs/Pose2D` on the `/intro/pose2d` topic and then run your simulation from Problem 10 in Underwater Physics whenever a callback is received. The node should use the fields from the `Pose2D` message for `x0`, `y0`, and `theta0` in the simulation. Test your code by entering `ros2 topic topic pub /intro/pose2d geometry_msgs/Pose2D '{x: 1.0, y: 2.0, theta: 0.5}'` in a seperate terminal while the node is running. You should save your graphs as PNG files on the `backseat`.
