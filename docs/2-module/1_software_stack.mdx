---
sidebar_position: 1
---

# Programming an Underwater Robot: Software Stack

## ROS2 Terminology

ROS2 (Robot Operating System 2) is a set of open-source libraries and tools used to build robotics applications. It is commonly used in robotics research and industry.

### Nodes

Nodes are instances of executables that act as individual computation entitites in the ROS2 environment. They perform specific tasks, such as processing sensor data or controlling hardware. Nodes communicate with each other by publishing and subscribing to topics or by using services. Nodes typically consist of combinations of publishers, subscribers, and services.

### Topics

Topics are named buses that nodes use to exchange messages. Nodes can both publish messages on a topic and receive messages in a callback function on a subscribed topic. Each topic is limited to an individual message type specified in a node's executable.

### Messages

Messages are data structures used to communicate information between nodes via topics. These structures contain combinations of fields and data types, and are defined in .msg files. The field is the name of specific data in the structure, while the data type is typically either a primitive data type or another message type. Messages define specific information such as sensor data or control input.

### Publishers & Subscribers

Publishers and subscribers are communication interfaces that enable nodes to communicate. A publisher sends messages on a topic and a subscriber receives messages on a topic.

### Services

Services and clients provide an alternate communication interface with a request-response mechanism. A client sends requests to a service and receives responses after the service completes its task.

## ROS2 Environment

To access ROS2 packages from a terminal, the ROS2 environments must be sourced. There are two types of environments: the ROS2 distribution from the installation process and ROS2 workspaces. Create a new workspace for this course:

```bash
cd && mkdir auvc_ws && cd auvc_ws && mkdir src
```

In the workspace, all user-defined packages are located in the `src` directory. The ROS2 compiler `colcon` will not compile your packages if they are not located in the `src` directory. Initialize the workspace by building with an empty `src` directory:

```bash
source /opt/ros/jazzy/setup.zsh
cd ~/auvc_ws && colcon build --symlink-install
```

:::note

The --symlink-install argument creates symbolic links to node executables that reduces subsequent build times.

:::

Now, using your favorite text editor, open the `.zshrc` file and add the following lines:

```bash
source /opt/ros/jazzy/setup.zsh
source $HOME/auvc_ws/install/setup.zsh
```

Then, resource the `.zshrc` file:

```bash
source ~/.zshrc
```

All distribution packages and your user-defined packages in `~/auvc_ws/src` will automatically be sourced every time a new terminal is started. Without this step, you would need to execute both lines added to the `.zshrc` file in every new terminal opened; otherwise, ROS2 is inaccessible in that terminal.

## ROS2 Example Nodes

This section provides an overview of an offical [ROS2 tutorial](https://docs.ros.org/en/jazzy/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html) for writing a simple publisher and subscriber with some modifications. To start, navigate to into_to_ros package and open `publisher.py` with your favorite text editor.

The first few lines of code import `rclpy`, the ROS2 client library for Python. You must also import any message types that the node uses. Add the following lines:

```bash
#!/env/usr/bin python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Vector3
```

Next, create a class which inherits from `Node`:

```bash
class TutorialPublisher(Node):
```

Now add the class's constructor. `super().__init__("nodename")` initializes a node called nodename. `create_publisher` declares that the node publishes the named message type to the named topic and its queue size.

```bash
def __init__(self):
    super().__init__("tutorial_publisher")
    self.pub = self.create_publisher(Vector3, "/tutorial/vector3", 10)
```

In this case, the publisher named `pub` will publish `Vector3` messages to the topic named `/tutorial/vector3`. Define a method to run the node. For this node, we want to publish a single `Vector3` message and then shutdown the node. Add the following method to the `TutorialPublisher` class:

```bash
def run_node(self):
    msg = Vector3()
    msg.x = 3
    msg.y = 4
    msg.z = 5
    self.pub.publish(msg)
```

Lastly, we define the main function:

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialPublisher()
    node.run_node()
    node.destroy_node()
    rclpy.shutdown()

if __name__=="__main__":
    main()
```


### 

## Problem Set

### Problem One




