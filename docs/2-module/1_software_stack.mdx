---
sidebar_position: 1
---

# Programming an Underwater Robot: Software Stack

## ROS2 Terminology

ROS2 (Robot Operating System 2) is a set of open-source libraries and tools used to build robotics applications. It is commonly used in robotics research and industry.

### Nodes

Nodes are instances of executables that act as individual computation entitites in the ROS2 environment. They perform specific tasks, such as processing sensor data or controlling hardware. Nodes communicate with each other by publishing and subscribing to topics or by using services. Nodes typically consist of combinations of publishers, subscribers, and services.

### Topics

Topics are named buses that nodes use to exchange messages. Nodes can both publish messages on a topic and receive messages in a callback function on a subscribed topic. Each topic is limited to an individual message type specified in a node's executable.

### Messages

Messages are data structures used to communicate information betyouen nodes via topics. These structures contain combinations of fields and data types, and are defined in .msg files. The field is the name of specific data in the structure, while the data type is typically either a primitive data type or another message type. Messages define specific information such as sensor data or control input.

For example, in the built-in geometry_msgs package, a `Vector3` message defines a vector in free space. `Vector3.msg` is structured as:

```bash
float64 x
float64 y
float64 z
```

In this message type, there are three fields representing the magnitude of the vector in the primary axes. Each of these fields represents a float64 value in the message.

### Publishers & Subscribers

Publishers and subscribers are communication interfaces that enable nodes to communicate. A publisher sends messages on a topic and a subscriber receives messages on a topic.

### Services

Services and clients provide an alternate communication interface with a request-response mechanism. A client sends requests to a service and receives responses after the service completes its task.

## ROS2 Environment

To access ROS2 packages from a terminal, the ROS2 environments must be sourced. There are two types of environments: the ROS2 distribution from the installation process and ROS2 workspaces. Create a new workspace for this course:

```bash
cd && mkdir auvc_ws && cd auvc_ws && mkdir src
```

In the workspace, all user-defined packages are located in the `src` directory. The ROS2 compiler `colcon` will not compile your packages if they are not located in the `src` directory. Initialize the workspace by building with an empty `src` directory:

```bash
source /opt/ros/jazzy/setup.zsh
cd ~/auvc_ws && colcon build --symlink-install
```

:::note

The --symlink-install argument creates symbolic links to node executables that reduces subsequent build times.

:::

Using your favorite text editor, open the `.zshrc` file and add the following lines:

```bash
source /opt/ros/jazzy/setup.zsh
source $HOME/auvc_ws/install/setup.zsh
```

Then, resource the `.zshrc` file:

```bash
source ~/.zshrc
```

Now, all distribution packages and all your user-defined packages in `~/auvc_ws/src` will be automatically sourced in every new terminal that you open. Without this step, you would need to execute both lines added to the `.zshrc` file in every new terminal opened; otherwise, ROS2 is inaccessible in that terminal.

## ROS2 Terminal Commands



## ROS2 Example Nodes

This section provides an overview of an offical [ROS2 tutorial](https://docs.ros.org/en/jazzy/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html) for writing a simple publisher and subscriber with some modifications.

### Publisher Node

To start, navigate to into_to_ros package and open `publisher.py` with your favorite text editor. The first few lines of code import `rclpy`, the ROS2 client library for Python. You must also import any message types that the node uses. Add the following lines:

```bash
#!/env/usr/bin python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Vector3
```

Next, create a class which inherits from `Node`:

```bash
class TutorialPublisher(Node):
```

Now add the class's constructor. `super().__init__("nodename")` initializes a node called nodename. `create_publisher` declares that the node publishes the named message type to the named topic and its queue size.

```bash
def __init__(self):
    super().__init__("tutorial_publisher")
    self.pub = self.create_publisher(Vector3, "/tutorial/vector3", 10)
    self.get_logger().info("Started Tutorial Publisher Node")
```

In this case, the publisher named `pub` will publish `Vector3` messages to the topic named `/tutorial/vector3`. Define a method to run the node. For this node, you want to publish a single `Vector3` message and then shutdown the node. Add the following method to the `TutorialPublisher` class:

```bash
def run_node(self):
    msg = Vector3()
    msg.x = 3
    msg.y = 4
    msg.z = 5
    self.pub.publish(msg)
    self.get_logger().info("Vector3 msg published to /tutorial/vector3")
```

Lastly, you define the main function:

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialPublisher()
    node.run_node()
    node.destroy_node()
    rclpy.shutdown()

if __name__=="__main__":
    main()
```

### Subscriber Node

Save and exit the `publisher.py` file. Now open `subscriber.py`. In this node, you want to subscribe to messages published by `publisher.py` and print the corresponding unit vector to the terminal. you start with the same imports used in the publisher node. Then, define your class and constructor:

```bash
class TutorialSubscriber(Node)
```

```bash
def __init__(self):
    self.sub = self.create_subscription(
        Vector3,
        "/tutorial/vector3",
        self.callback,
        10
    )
    self.subscription
    self.get_logger().info("Started Tutorial Subscriber Node")
```

In the class's constructor, `create_subscription` declares that the node subscribes to `Vector3` messages on the named topic `/tutorial/vector3` and that these messages are directed to the `callback` method. Next, define the callback method:

```bash
def callback(self, msg):
    magnitude = np.sqrt(msg.x ** 2 + msg.y ** 2 + msg.z ** 2)
    data = Vector3()
    data.x = msg.x / magnitude
    data.y = msg.y / magnitude
    data.z = msg.z / magnitude
    self.get_logger().info(f"\nVector3\n\tx: {data.x}\n\ty: {data.y}\n\tz: {data.z})
```

Lastly, you define our main function:

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__=="__main__":
    main()
```

Here, instead of having the node perform a single task like the publisher node, you use `rclpy.spin` to keep the node active.

### Building the Nodes

To build the nodes, you must update `CMakeLists.txt` and `package.xml` with the dependencies from our nodes. First, open `CMakeLists.txt` and add `find_package` for each package defined in any nodes in the packages `src` directory.

```bash
find_package(rclpy REQUIRED)
find_package(geometry_msgs REQUIRED)
```

You must also specify executables in the node. Below `ament_python_install_package` add:

```bash
install(PROGRAMS
    src/publisher.py
    src/subscriber.py
    DESTINATION lib/${PROJECT_NAME}
)
```

Second, open `package.xml` and add a `build_depend` and `exec_depend` line for each imported module. Below `buildtool_depend` add:

```bash
<build_depend>rclpy</build_depend>
<build_depend>geometry_msgs</build_depend>

<exec_depend>rclpy</exec_depend>
<exec_depend>geometry_msgs</exec_depend>
```

Now navigate to the ROS2 workspace  and build the nodes.

```bash
cd ~/auvc_wc
colcon build --symlink-install
```

### Testing the Nodes

Open a new terminal and start the subscriber node:

```bash
ros2 run intro_to_ros subscriber.py
```

In the terminal, you should see the message the subscriber node has started. Open a second terminal and run the publisher node:

```bash
ros2 run intro_to_ros publisher.py
```

In the terminal running the subscriber node, you should see the unit vector equivalent of the `Vector3` message received from the publisher node.






## Problem Set

### Problem One




