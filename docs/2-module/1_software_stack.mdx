---
sidebar_position: 1
---

# Programming an Underwater Robot: Software Stack

## ROS2 Terminology

ROS2 (Robot Operating System 2) is a set of open-source libraries and tools used to build robotics applications. It is commonly used in robotics research and industry.

### Nodes

Nodes are instances of executables that act as individual computation entitites in the ROS2 environment. They perform specific tasks, such as processing sensor data or controlling hardware. Nodes communicate with each other by publishing and subscribing to topics or by using services. Nodes typically consist of combinations of publishers, subscribers, and services.

### Topics

Topics are named buses that nodes use to exchange messages. Nodes can both publish messages on a topic and receive messages in a callback function on a subscribed topic. Each topic is limited to an individual message type specified in a node's executable.

### Messages

Messages are data structures used to communicate information betyouen nodes via topics. These structures contain combinations of fields and data types, and are defined in .msg files. The field is the name of specific data in the structure, while the data type is typically either a primitive data type or another message type. Messages define specific information such as sensor data or control input.

For example, in the built-in geometry_msgs package, a `Vector3` message defines a vector in free space. `Vector3.msg` is structured as:

```bash
float64 x
float64 y
float64 z
```

In this message type, there are three fields representing the magnitude of the vector in the primary axes. Each of these fields represents a float64 value in the message.

### Publishers & Subscribers

Publishers and subscribers are communication interfaces that enable nodes to communicate. A publisher sends messages on a topic and a subscriber receives messages on a topic.

### Services

Services and clients provide an alternate communication interface with a request-response mechanism. A client sends requests to a service and receives responses after the service completes its task.

## ROS2 Environment

To access ROS2 packages from a terminal, the ROS2 environments must be sourced. There are two types of environments: the ROS2 distribution from the installation process and ROS2 workspaces. First, setup the `.zshrc` file to automatically source the ROS2 installation. In a terminal, type:

```bash
echo "source /opt/ros/jazzy/setup.zsh" >> $HOME/.zshrc
```

Then, create a workspace for this course named `auvc_ws`:

```bash
cd && mkdir auvc_ws && cd auvc_ws && mkdir src
```

In a workspace, all user-defined packages are located within the `src` directory. The ROS2 compiler `colcon` will not compile your packages if they are not located in the `src` directory of the workspace you are currently building. Initialize the workspace by building with an empty `src` directory. 

```bash
cd ~/auvc_ws && colcon build
```

Now, setup the `.zshrc` file to automatically source the `auvc_ws` ROS2 workspace. In a terminal, type:

```bash
echo "source $HOME/auvc_ws/install/setup.zsh" >> $HOME/.zshrc
```

Then, resource the `.zshrc` file:

```bash
source ~/.zshrc
```

Now, all distribution packages and all your user-defined packages in `~/auvc_ws/src` will be automatically sourced in every new terminal that you open. Without this step, you would need to execute both lines added to the `.zshrc` file in every new terminal opened; otherwise, ROS2 would be inaccessible in that terminal.

## ROS2 Terminal Commands

Here are some terminal commands that you may find useful for general use and testing/debugging.

### General Use

1. Build packages in a ROS2 workspace:
- Packages must be located in your_ws/src/.
- Build command must be run in your_ws/.

```bash
colcon build
```

2. Build specific packages in ROS2 workspace:

```bash
colcon build --packages-select my_package
```

3. Run an individual node:
- If the executable is not found, try `source ~/.zshrc` and then `chmod +x $HOME/auvc_ws/src/path_to_executable`.

```
ros2 run my_package my_executable.py
```

4. Create a new node:
- You will need to configure the `CMakeLists.txt` and `package.xml` files like as shown in ROS2 Example Nodes.

```bash
ros2 pkg create --build-type ament_python your_node_name
```

### Testing & Debugging

1. View a list of all active nodes:

```bash
ros2 node list
```

2. View a list of all named topics:

```bash
ros2 topic list
```

3. View the message type of a topic:

```bash
ros2 topic type /your/topic
```

4. View messages on a topic in the terminal:

```bash
ros2 topic echo /your/topic
```

5. Publish a message on a topic (replace `N` with the number of times you want to publish the message):

```bash
ros2 topic pub -N /your/topic std_msgs/String "{data: 'hello from terminal'}"
```

6. View a topic's rate:

```bash
ros2 topic hz /your/topic
```

## ROS2

This section provides an overview of an offical [ROS2 tutorial](https://docs.ros.org/en/jazzy/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html) for writing a simple publisher and subscriber with some modifications.

The example publisher node publishes a single `Vector3` message. The subscriber node subscribes to the `Vector3` message and prints the corresponding unit vector to the terminal.

For this lesson and the subsequent problem set, you will fork and work on your own copy of the `intro_to_ros` repository. After creating your fork, clone it into `auvc_ws/src` on the `backseat`.  In any given ROS2 package that uses the `ament_python` build tool (the only build tool we'll be using), all executables are located within `your_ws/src/package_name/package_name/`.

### Publisher Node

To start, open the `publisher.py` file. The first lines of code are the shebang and the imports. In each ROS2 node, you must import the appropriate ROS2 client library for either python or c++, respectively. You must also import any message and service types that you use in the node. In this example, only the `Vector3` message type is used. Add the following lines:

```bash
#!/env/usr/bin python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Vector3
```

Next, create a class for the publisher node which inherits from `Node`:

```bash
class TutorialPublisher(Node):
```

Within the class's constructor, `super().__init__("nodename")` initializes a ROS2 node called nodename and `create_publisher` declares that the node publishes `Vector3` to the topic named `/tutorial/vector3` with a queue size of `10`.

```bash
def __init__(self):
    super().__init__("tutorial_publisher")
    self.pub = self.create_publisher(
        Vector3, 
        "/tutorial/vector3", 
        10
    )
    self.get_logger().info("Started Tutorial Publisher Node")
```

Given that the publisher's task is to execute a one-time process, define a method to run the node:

```bash
def run_node(self):
    msg = Vector3()
    msg.x = 3
    msg.y = 4
    msg.z = 5
    self.pub.publish(msg)
    self.get_logger().info("Vector3 msg published to /tutorial/vector3")
```

Lastly, define the main function:

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialPublisher()

    try:
        node.run_node()
    except KeyboardInterrupt:
        print("\nKeyboardInterrupt received, shutting down...")
    finally:
        node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()

if __name__=="__main__":
    main()
```

### Subscriber Node

Save and exit the `publisher.py` file. Now open `subscriber.py`. Use the same shebang and imports from the publisher node with the addition of `import numpy as np`. 

Next, create a class for the subscriber node which inherits from `Node`:

```bash
class TutorialSubscriber(Node):
```

Within the class's constructor, `super().__init__("nodename")` initializes a ROS2 node called nodename and `create_subscription` declares that the node subscribes to `Vector3` to the topic named `/tutorial/vector3` with a queue size of `10`. All messages on this topic received by the subscriber node are passed to the `self.callback` method.

```bash
def __init__(self):
    super().__init__("tutorial_publisher")
    self.sub = self.create_subscription(
        Vector3,
        "/tutorial/vector3",
        self.callback,
        10
    )
    self.sub
    self.get_logger().info("Started Tutorial Subscriber Node")
```

Next, define the callback method:

```bash
def callback(self, msg):
    magnitude = np.sqrt(msg.x ** 2 + msg.y ** 2 + msg.z ** 2)
    data = Vector3()
    data.x = msg.x / magnitude
    data.y = msg.y / magnitude
    data.z = msg.z / magnitude
    self.get_logger().info(f"\nVector3\n\tx: {data.x}\n\ty: {data.y}\n\tz: {data.z}")
```

Lastly, define the main function.

```bash
def main(args=None):
    rclpy.init(args=args)
    node = TutorialSubscriber()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\nKeyboardInterrupt received, shutting down...")
    finally:
        node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()

if __name__=="__main__":
    main()
```

Here, instead of using a method like `run_node` from the publisher node, `rclpy.spin(node)` keeps the node running until it is shutdown by the user.

### Building the Package

Before building the package, the `setup.py` file must be updated to include entry points for each executable. Add the following lines within the square brackets in `entry_points={'console_scripts': [],}`:

```bash
'publisher = intro_to_ros.publisher:main',
'subscriber = intro_to_ros.subscriber:main',
```

Next, open `package.xml` and all dependencies from nodes in the package. Below the `license` line, add:

```bash
<build_depend>rclpy</build_depend>
<build_depend>geometry_msgs</build_depend>

<exec_depend>rclpy</exec_depend>
<exec_depend>geometry_msgs</exec_depend>
```

To build the package, check for any missing dependencies and then run the `colcon build` command:

```bash
cd $HOME/auvc_ws
rosdep install -i --from-path src --rosdistro jazzy -y
colcon build --symlink-install --packages-select intro_to_ros
source install/setup.zsh
```

### Testing the Nodes

Open a new terminal and start the subscriber node:

```bash
ros2 run intro_to_ros subscriber.py
```

In the terminal, you should see the message the subscriber node has started. Open a second terminal and run the publisher node:

```bash
ros2 run intro_to_ros publisher.py
```

In the terminal running the subscriber node, you should see the unit vector equivalent of the `Vector3` message received from the publisher node.

## Problem Set

### Problem One

Create a new ROS2 package called `underwater_physics`. Your package should contain a node called `simulator.py` that subscribes to the `geometry_msgs/Pose2D` messages on the topic named `/intro/pose2d`. 

The first time that the node receives a message, it should run your simulation from Problem 10 in the Underwater Physics problem set. Use `x0 = msg.x`, `y0 = msg.y`, and `theta0 = msg.theta` as initial conditions in your simulation.

Your node should save the resulting graphs as PNG files on the `backseat`. Test your code by entering the following command in a terminal on the `backseat` while your node is running:

```bash
ros2 topic pub -1 /intro/pose2d geometry_msgs/Pose2D '{x: 1.0, y: 2.0, theta: 0.5}'
```
